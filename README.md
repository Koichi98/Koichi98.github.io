# Distributed Systems 
## Chapter7 Mutual Exclusion
### 1.Introduction
排他制御は並列プログラミングにおいて根本的な問題であり、様々なコンテキストで研究されてきた。

### 2.Message-Passing Systemsに対する解法
前提条件
- n プロセスによる分散システム
- それぞれのプロセスが他のすべてのプロセスに直接通信できる全結合グラフ
- 各プロセスはCritical Section (CS) に定期的に進入し、CSを実行し、CSを出て他の作業を行う

問題定義 - 以下の3つの条件を満たすようなプロトコルを考えたい
- ME1: [Mutual exclusion] 任意の時刻で、最大一つのプロセスがCS内にに存在し得る (safety)
- ME2: [Freedom from deadlock] **あらゆる構成において**、最低でも一つのプロセスがactionを起こして、CS内に進入可能である。(safety)
- ME3: [Progress] CSに侵入しようとしているすべてのプロセスが最終的にはそれに成功する (liveliness)

#### 2.1 Lamportの解法

- 全結合グラフで動作
- 通信チャネルはFIFO
- 各プロセスはrequest-queue Qを保持

以下の5つのルールによって説明される
- LA1: CSへの侵入のリクエストをする際には、プロセスはタイムスタンプが付与されたリクエストを他のすべてのプロセスに送信し、自分のQにもそのリクエストを加える。
- LA2: プロセスがリクエストを受信した際には、それをQに加える。自身がCSにいない場合にはタイムスタンプが付与されたackを送信者に返し、CSにいる場合にはCSから退出する。
- LA3: プロセスは(1)自分の持つQのにおいて自身のリクエストのタイムスタンプが他のすべてのリクエストのものよりも小さく、かつ(2)そのリクエストに対してのackを他のすべてのプロセスから受け取った際にCSに進入する。
- LA4: CSから退出するときには、(1)当該リクエストを自身のQから削除し、また(2)タイムスタンプが付与されたreleaseメッセージを他のすべてのプロセスに送信する。
- LA5: プロセスがreleaseメッセージを受け取った際には、対応するリクエストを自身のQから削除する。

Message Complexity - CSに進入して退出するのに必要なメッセージの数
各プロセスは(n-1)メッセージをリクエストに、(n-1)メッセージをackとして受け取り、さらに(n-1)メッセージをrelease messageとして退出時に送信するので3(n-1)。

#### 2.2 Ricart-Agrawalaの解法
Lamportの解法を改善。各プロセスは個別にqueueを持つのではなく、受け取ったackの数を数える。(通信チャネルはFIFOでなくてもよい)
- RA1:CSに進入しようとしている各プロセスはタイムスタンプが付与されたリクエストを他の全てのプロセスに送信する。
- RA2: リクエストを受信したプロセスは以下のどちらかを満たすときのみackを返す。(1)自身がCSに進入しようとしていない。(2)CSに進入しようとしているが、そのタイムスタンプが受信したリクエストに付与されているタイムスタンプよりも大きい。受信したプロセスがすでにCSに進入している場合、もしくは自身のタイムスタンプのほうが小さい場合には、自身がCSを退出するまでリクエストを**バッファする**
- RA3: プロセスは送信したリクエストに対してのackを他のすべてのプロセスから受け取った際にCSに進入する。
- RA4: CSから退出する際には、新たなリクエストを作ったり、他の作業を行ったりする前に、バッファしていたリクエスト全てに対してackを送信する必要がある。

Message Complexity
各プロセスは(n-1)メッセージをリクエストに、(n-1)メッセージをackとして受け取るので2(n-1)。

#### 2.3 Maekawaの解法

### 3 Token-Passing Algorithms
トークンと呼ばれるものをCSへの進入の許可証として利用し、プロセス間で渡し合うことという方法。

#### 3.1 Suzuki-Kasami Algorithm
- 全結合グラフに対して定義されるアルゴリズム
- トークンを持たないプロセスiはCSに進入したい際に、リクエスト(i,num)を送信する。(numはsequence number)
- 各プロセスは整数配列req[0.. n-1]を持ち、req[j]はプロセスjから受信した直近のリクエストのsequence number
- トークンが持つデータ構造は以下の2つ。
  - (1)プロセスjによって直近で実行された際のsequence numberをlast[j]が表す、整数配列last[0.. n-1]
  - (2)トークンを待っているプロセスidをためておくためのqueue Q

アルゴリズム
- 進入時
  -  プロセスiがCSに進入したいがトークンを持たない際に、プロセスiは自身のreq_i[i]のsequence numberをインクリメントし、トークンを要求するためにリクエストメッセージ(i,sn)を他のすべてのプロセスに送信する。
  -  


  
